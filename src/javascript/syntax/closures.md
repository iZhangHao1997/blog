# 执行上下文/作用域链/闭包

- [执行上下文和作用域的理解](https://segmentfault.com/a/1190000011843356)
- [执行上下文和作用域的区别](https://www.cnblogs.com/wangfupeng1988/p/3991995.html)

## 执行上下文

执行上下文（Execution Context），也就是程序代码执行时候的环境，决定了变量或函数有权访问的其他数据：分为**全局执行上下文**、**函数执行上下文**以及**eval 执行上下文**（一般不涉及，不讨论）。

每个函数都有自己的执行环境。当代码在一个环境中执行的时候，会创建变量对象的一个**作用域链（scope chain）**。

### 全局执行上下文

全局执行上下文只有一个，在客户端中**一般由游览器创建**，也就是 `window` 对象，我们可以通过 `this` 直接访问它。

全局对象 `window` 上预定义了大量的方法和属性，我们在全局环境的任何一个地方都可以直接访问这些属性和方法；同时，`window` 对象还是 `var` 声明的全局变量的载体，我们通过 `var` 创建的全局变量，都可以通过 `window` 直接访问。

### 函数执行上下文

函数执行上下文可以存在无数个，每个函数被调用的时候都会创建一个函数上下文；需要注意的是，**同一个函数被多次调用，都会创建一个新的上下文**。

那么上下文种类不同，数量多，它们之间的关系是怎样的，又是如何管理的呢？这就关系到**执行上下文栈**。

### 执行上下文栈

执行上下文栈（简称执行栈），也称调用栈，**执行栈用于存储代码执行期间所创建的所有上下文**，具有 LIFO（Last In First Out 后进先出，也就是先进后出）的特性。

JS 代码首次运行，都会**先创建一个全局执行下文并压入到执行栈中**，之后每当有函数被调用，都会创建一个新的函数执行上下文并压入栈内；由于执行栈的 LIFO 后进先出特性，所以可以理解为，JS 代码执行完毕前在执行栈底部永远有一个全局执行上下文。

## 作用域链

### 什么是作用域

JS 在 ES6 之前并没有块级作用域，除了全局作用域，函数会创建自己的作用域。作用域在函数定义时就已经确定了，不是在函数调用时确定（区别于执行上下文环境，当然 `this` 也是属于上下文环境）

```js
// 全局作用域
let x = 100;

// fn作用域
function fn(x) {
  // bar作用域
  function bar(x) {
    console.log(x);
  }
}

let f1 = fn(5);
let f2 = fn(10);

f1(); // 5
f2(); // 10
```

作用域只是一个“地盘”，其中没有变量。**变量是通过作用域对应的执行上下文环境中的变量对象来实现的**。所以作用域是静态观念的，而执行上下文环境是动态上的，两者并不一样。有闭包存在时，一个作用域存在两个上下文环境也是有的。

同一个作用域下，对同一个函数的不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值，**所以，作用域中变量的值是在执行过程中确定的，而作用域是在函数创建时就确定的。**

**如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中找到变量的值。**

### 什么是作用域链

函数在定义的时候（不是调用的时候）就已经确定了函数体内部自由变量的作用域。

比如上例，当我们调用 `bar` 函数时，先会从 `bar` 作用域取值，如果 `bar` 作用域没有，就到创建 `bar` 的 `fn` 作用域寻找，如果 `fn` 也没有，就到了全局作用域，找到这里就结束了。

作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。

## 闭包

JS 的“闭包”也是面试几乎必问的概念，那么什么是闭包？

如果一句话解释: **能够读取其他函数内部变量的函数**

> 但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递。

稍全面的回答：**在 js 中变量的作用域属于函数作用域, 在函数执行完后,作用域就会被清理,内存也会随之被回收,但是由于闭包函数是建立在函数内部的子函数, 由于其可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 这时的子函数(也就是闭包),便拥有了访问上级作用域中变量的权限,即使上级函数执行完后作用域内的值也不会被销毁。**

### 闭包的应用场景

在开发中, 其实我们随处可见闭包的身影, 大部分前端 JavaScript 代码都是“事件驱动”的，即一个事件绑定的回调方法; 发送 ajax 请求成功/失败的回调；setTimeout 的延时回调；或者一个函数内部返回另一个匿名函数，这些都是闭包的应用。

1. 读取值问题：

   ```js
   for (var i = 0; i < 10; i++) {
     setTimeout(function () {
       console.log(i); // 10个10
     }, 1000);
   }
   ```

   如何读取到正确的值：

   ```js
   // 使用 let 变量声明 i
   for (let i = 0; i < 10; i++) {
     setTimeout(function () {
       console.log(i); // 10个10
     }, 1000);
   }
   ```

   或者

   ```js
   // 声明了 10 个自执行函数，保存当时的值到内部
   for (var i = 0; i < 10; i++) {
     ((j) => {
       setTimeout(function () {
         console.log(j); //1-10
       }, 1000);
     })(i);
   }
   ```

1. 使用闭包模拟私有变量

   ```js
   var counter = (function () {
     var privateCounter = 0;

     function changeBy(val) {
       privateCounter += val;
     }
     return {
       increment: function () {
         changeBy(1);
       },
       decrement: function () {
         changeBy(-1);
       },
       value: function () {
         return privateCounter;
       },
     };
   })();
   counter.value(); //0
   counter.increment(); //1
   counter.increment(); //2
   counter.decrement(); //1
   ```

   匿名函数已经定义就立即执行, 创建出一个词法环境包含 `counter.increment`、`counter.decrement`、`counter.value` 三个方法，还包含了两个私有项：`privateCounter` 变量和 `changeBy` 函数。这两个私有项无法在匿名函数外部直接访问，必须通过匿名包装器返回的对象的三个公共函数访问。

### 闭包的缺点

1. 由于闭包会是的函数中的变量都被保存到内存中,滥用闭包很容易造成内存消耗过大,导致网页性能问题。解决方法是在退出函数之前，将不再使用的局部变量全部删除。
1. 闭包可以使得函数内部的值可以在函数外部进行修改。所有，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
