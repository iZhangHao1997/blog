# 数据类型

## 类型分类

JavaScript 的数据类型主要分为两类：**原始类型(基本类型)**和**引用类型(对象类型)**。

### 基本类型

- **String**
  - 转换方法：数值、布尔值、对象和字符串值都有 `toString()` 方法。
- **Number**
  - 双精度 64 位二进制格式的值——数字、±Infinity(如果超过(5e-324, 1.7976931348623157e+308))、NaN(与任何值都不相等，包括本身，请使用 `isNaN()`)；
  - 可使用零（0）开头表示八进制，如 `const num = 070; // 八进制的 56`（严格模式无效）；
  - 可用 `0x` 开头表示十六进制，进行运算时所有八进制和十六进制表示的数值最终都会被转化为十进制；
  - 数值转换的方法：`Number()`、`parseInt()`和 `parseFloat()`，用法/区别请自行查阅；
  - 注意：由于浮点数值的精度问题，`0.1 + 0.2 = 0.30000000000000004`。
- **Boolean**
- **null**
  - JS 的数据底层都是用二进制进行存储的，前三位为 0 会被判断成对象，null 是全部为 0；
  - 表示空对象的指针，所以使用 `typeof` 操作符检测 `null` 值会返回 `'object'`。
- **undefined**
  - 不管是否定义/初始化，使用 `typeof` 操作符均返回 `'undefined'` ，注意 `null == undefined` 将返回 true。
- **Symbol**
  - ES6 新增定义，实例是唯一且不可变的；
  - [学习地址](https://es6.ruanyifeng.com/#docs/symbol)
- **BigInt**
  - BigInt 是一种内置对象，它提供了一种方法来表示大于 `2^53 - 1` 的整数。这原本是 Javascript 中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数。
  - 可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：10n，或者调用函数 BigInt()。

#### 为什么 typeof null 等于 Object?

不同的对象在底层原理的存储是用二进制表示的，在 javaScript 中，如果二进制的前三位都为 0 的话，系统会判定为是 Object 类型。null 的存储二进制是 000，也是前三位，所以系统判定 null 为 Object 类型。

这个 bug 个第一版的 javaScript 留下来的。扩展一下其他的几个类型标志位：

- 000：对象类型。
- 1：整型，数据是 31 位带符号整数。
- 010：双精度类型，数据是双精度数字。
- 100：字符串，数据是字符串。
- 110：布尔类型，数据是布尔值。

#### JS 中的精度问题，如 0.1 + 0.2 为什么不等于(===) 0.3

[精度问题相关文章](https://xwjgo.github.io/2018/03/17/js%E4%B8%AD%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/)

[为什么 JavaScript 最大安全整数是 2^53-1](https://juejin.cn/post/6880143057930190855)

JS 中的数字按照 IEEE 754 标准，使用 64 位双精度浮点型来表示。其中符号位 S（Sign），指数位 E（Exponent），尾数位 F（fraction） 分别占了 1、11、52 位，并且在 ES5 规范中指出了指数位 E 的取值范围是 `[-1074, 971]`。

<img src="/img/javascript/双精度数字存储结构.png" />

| 位置  | 位数 | 作用   | 表示     |
| ----- | ---- | ------ | -------- |
| 0-51  | 52   | 尾数位 | 原码表示 |
| 52-62 | 11   | 指数位 | 移码表示 |
| 63    | 1    | 符号位 | 0/1      |

想用有限的位数表示无穷的数字，显然是不可能的，因此会出现一系列精度问题：

1. 浮点数精度问题，比如：0.1 + 0.2 !== 0.3
1. 大数精度问题，比如 9999 9999 9999 9999 === 1000 0000 0000 0000 1
1. toFixed 四舍五入结果不准确，比如 1.335.toFixed(2) === 1.33

浮点数精度和 toFixed 其实属于同一类问题，都是由于浮点数无法精确表示引起的，如下：

```js
(1.335).toPrecision(20); // '1.3349999999999999645'
```

而关于大数精度问题，可以先看下面的代码片段：

```js
// 能准确表示的整数范围上限， S为0， E为11个0，S为52个1
Math.pow(2, 53) - 1 === Number.MAX_SAFE_INTEGER; // true

// 能精确表示的整数范围下限,S为1个1，E为11个0，S为53个1
-(Math.pow(2, 53) - 1) === Number.MIN_SAFE_INTEGER; // true

// 能表达的最大数组：S为0，E为971，S为53个1
```

#### 出现 null 和 undefined 的情况

- null 出现的情况
  1. 手动设置变量的值或对象某一个属性值为 null
  1. 在 JS 的 DOM 元素获取中，如果没有获取到指定的元素对象，结果一般是 null
  1. Object.prototype.**proto** 的值也是 null
  1. 正则捕获的时候，如果没有捕获到的结果，默认也是 null
- undefined 出现的情况
  1. 变量提升：只声明未定义默认值就是 undefined
  1. 严格模式下：没有明确的执行主体，this 指向 undefined
  1. 对象没有这个属性名，属性值是 undefined
  1. 函数定义形参不传值，默认就是 undefined
  1. 函数没有返回值（没有 return，或者 return;），默认返回就是 undefined

### 引用类型

其实除了基本类型以外都是引用类型，包括但不限于以下：

- **Function**
- **Array**
- **Object**
- **Date**
- **RegExp**

## 存储形式

- 原始类型因为在内存种占固定大小的空间，所以保存在**栈内存种**；
- 引用类型的大小不固定，所以是按引用访问的，保存在**堆内存**中。（在栈内存中存一个基本类型值保存对象在堆内存中的地址，用于引用这个对象。）

<img src="/img/javascript/StackandHeap.png">

> 基本类型在当前执行环境结束时销毁，而引用类型不会随执行环境结束而销毁，只有当所有引用它的变量不存在时这个对象才被垃圾回收机制回收。

## 数据类型的判断

#### typeof 与 instanceof 有什么区别？

typeof 是一元运算符，同样返回一个字符串类型。一般用来判断一个变量是否为空或者是什么类型。
除了 null 类型以及 Object 类型不能准确判断外，其他数据类型都可能返回正确的类型。

```js
typeof undefined; // 'undefined'
typeof "10"; // 'String'
typeof 10; // 'Number'
typeof false; // 'Boolean'
typeof Symbol(); // 'Symbol'
typeof Function; // ‘function'
typeof null; // ‘Object’
typeof []; // 'Object'
typeof {}; // 'Object'
```

既然 `typeof` 对 null 、数组和数组类型都返回 `Object` 类型情况的局限性，我们可以使用 `instanceof` 来进行判断**某个对象是不是另一个对象的实例**。返回值的是一个布尔类型。

`instanceof` 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 `prototype` 属性。

那么 ES6 语法中的 `class` 语法糖是什么类型：

```js
class A {}
console.log(A instanceof Function); // true
```

假设有 `a instanceof b` 语句，则在 `instanceof` 内部实际做了如下判断：

```js
while (a.__proto__ !== null) {
  if (a.__proto__ === b.prototype) {
    return true;
  }
  a.__proto__ = a.__proto__.proto__;
}
return false;
```

`a` 会一直沿着隐式原型链 `__proto__` 向上查找直到 `a.__proto__.__proto__ ...... === b.prototype` 为止，如果找到则返回 `true`，也就是 `a` 为 `b` 的一个实例。否则返回 `false`，`a` 不是 `b`的实例。

> 注意：原型链中的 prototype 随时可以被改动的，改变后的值可能不存在于 object 的原型链上，instanceof 返回的值可能就返回 false。

## 双等和三等有什么区别

对于 `==` 来说，如果对比双方的类型**不一样**的话，就会进行类型转换。

假如我们需要对比的 `x` 和 `y` 是否相同，就会进行如下判断流程：

1. 首先会判断两者类型是否**相同**，相同的话就是比大小
1. 类型不相同的话，就会进行类型转换
1. 会判断是否在比对 `null` 和 `undefined`，如果是的话返回 `true`
1. 判断两者类型是否为 `string` 和 `number`，是的话将字符串转为 `number`

```js
1 == '1'
      ⬇
1 ==  1
```

1. 判断其中一方是否为 `boolean`，是的话就会将 `boolean` 转为 `number` 再进行判断

```js
'1' == true
        ⬇
'1' ==  1
 ⬇
 1  ==  1
```

1. 判断一方是否为 `object` 且另一方为为 `string`、`number` 或者 `symbol`，是的话就会把 `object` 转为原型类型再进行判断

```js
'1' == { name: 'yck' }
        ↓
'1' == '[object Object]'
```

这里提供流程图：

<img src="/img/javascript/图1.4.png">

对于 `===` 来说就简单多了，就是判断两者类型和值是否相同。

思考题： [] == ![] 会输出什么？

1. 两个操作数的数据类型相同，== 直接进行判断；数据类型不同，则要对操作数进行类型转换（大多数的面试题既然考 ==，本质上就是考类型转换）
2. 判断操作数的数据类型：
3. 如果都是原始类型(`string`/`number`/`boolean`，除去特殊值 `null`/`undefined`/`NaN`)，两者都转为数值进行判断；
4. 特殊值的话，`null`/`undefied`/`NaN` 和任何值(不包括自身) `==` 都为 `false`；`null` 和 undefined == 为 true，分别与自身 == 也为 true；NaN 与自身 == 为 false；
5. 原始类型和引用类型进行比较，原始类型是数值引用类型转为数值，原始类型是字符串引用类型转为字符串，原始类型是布尔值两者都转为数值；
6. 引用类型和引用类型进行比较，比较的是内存地址。

`[] == ![]` 的判断本质上是**原始类型**和**引用类型**的判断，一元运算符 `!` 优先级高于二元运算符 `==`，实际 `==` 判断时表达式已经转为 `[] == false`，然后 `==` 导致的隐式转换，二者都转为数值 `0 == 0` 就返回 `true` 了。
