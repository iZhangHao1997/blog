# 垃圾回收机制

当一个变量的生命周期结束后它所指向的内存就应该被释放。JS 有两种变量，全局变量和在函数中产生的局部变量。局部变量的声明周期在函数执行完毕就结束了，就可以将它的引用内存释放，即垃圾回收，但全局变量生命周期会持续到游览器关闭。

## 标记清除（mark and sweep）

这是大部分游览器进行垃圾回收的方式，当变量进入执行环境（函数中声明变量）的时候，垃圾回收期将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量。标记方式不定，可以是某个特殊位的反转或维护一个列表等。

垃圾收集器给内存中的所有变量都加上标记，然后**去掉全局环境中的变量以及被变量引用标记的变量**，进行垃圾回收。

## 引用计数（reference counting）

这种方式常常会引起内存泄漏，低版本的 IE 使用这种方式。机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加 1，当这个变量指向其他一个时该值的引用次数便减一。当该值引用次数为 0 时就会被回收。

该方式会引起内存泄漏的原因是它不能解决循环引用的问题：

```js
function sample() {
  var a = {};
  var b = {};
  a.prop = b;
  b.prop = a;
}
```

这种情况下每次调用 sample()函数，a 和 b 的引用计数都是 2，会使这部分内存永远不会被释放，即内存泄漏。

低版本 IE 中有一部分对象并不是原生 JS 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++以 COM(Component Object Model)对象的形式实现的，而 COM 对象的垃圾收集机制采用的就是引用计数策略。

因此即使 IE 的 js 引擎是用的标记清除来实现的，但是 js 访问 COM 对象如 BOM,DOM 还是基于引用计数的策略的，也就是说只要在 IE 中设计到 COM 对象，也就会存在循环引用的问题。

当一个 DOM 元素和一个原生的 js 对象之间的循环引用时：

```js
var ele = document.getElementById("eleId");
var obj = {};
obj.property = ele;
ele.property = obj;
```

添加 obj.property = null;ele.property = null;即可解除原生 JS 对象与 DOM 元素之间的连接。
