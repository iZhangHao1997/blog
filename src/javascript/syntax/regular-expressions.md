# 正则表达式

在正则表达式中，如果直接给出字符，就是精确匹配。`\d` 可以匹配一个数字，`\w`可以匹配一个字母或数字，`\s`可以匹配一个空格（也包括 Tab 等空白符），`.` 可匹配任意字符，所以

- `'00\d'` 可以匹配 `'007'`，但无法匹配 `'00A'`
- `'\d\d\d'` 可以匹配 `'010'`
- `'\w\w'` 可以匹配 `'js'`
- `'js.'` 可以匹配 `'jsp'`、`'js1'`、`'js!'` 等等。

要匹配变长的字符，在正则表达式中，用 `*` 表示任意个字符（包括 0 个），用 `+` 表示至少一个字符，用 `？` 表示 0 个或者 1 个字符，用 `{n}` 表示 n 个字符，用 `{n,m}` 表示 n-m 个字符。

看一个稍微复杂的例子：`\d{3}\s+\d{3,8}`.
从左往右解读一下：

1. `\d{3}` 表示匹配 3 个数字，例如 `010`
1. `\s+` 表示匹配至少一个空格（也包括 Tab 等其他空白符），所以 `\s+` 表示至少又一个空格，例如匹配 `' '`，`'\t\t'` 等
1. `\d{3,8}` 表示匹配 3-8 个数字，例如 `'1234567'`

综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。

如果要匹配 `010-12345` 这样的电话号码呢？由于 `-` 是一个特殊字符，在正则表达式中，要用 `'\'` 转义，所以正则为 `'\d{3}\-\d{3,8}'`。

但是，依然无法匹配 `'010 - 12345'`，因为带有空格。所以我们需要更复杂的匹配方式：`/\d{3}\s*\-\s*\d{5}/`

## 进阶

要做更精准地匹配，可以用 `[]` 表示范围，比如：

- `[0-9a-zA-Z\_]` 可以匹配一个数字、字母或者下划线
- `[0-9a-zA-Z\_]+` 可以匹配至少由一个数字、字母或者下划线组成的字符串，比如： `zara11`、`Zh_2020` 等
- `[a-zA-Z\_\$][0-9a-zA-Z\_\$]*` 可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母、下划线、`$` 组成的字符串，也就是 JavaScript 允许的变量名
- `[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}` 更精确地限制了变量的长度是 1-20 个字符（前面 1 个字符+后面最多 19 个字符）

`A|B` 可以匹配 A 或者 B，所以 `(J|j)ava(S|s)cript` 可以匹配 `'JavaScript'`、`'Javascript'`、`'javaScript'` 或者 `'javascript'`。

`^` 表示行的开头，`^\d` 表示必须以数字开头。

`$` 表示行的结束，`\d$` 表示必须以数字结束。

所以，`js` 可以匹配 `'ajs.~'`，但如果是 `^js$` 就变成整行匹配，就只匹配 `'js'` 了。

## RegExp

JavaScript 有两种方式创建一个正则表达式：

1. 第一种是直接通过 `/正则表达式/` 写出来，
2. 是通过 `new RegExp('正则表达式')` 创建一个 RegExp 对象。

两种写法是一样的：

```js
const reg1 = /^\d{3}\-\d{8}$/;
const reg2 = new RegExp("^\\d{3}\\-\\d{8}$");
```

reg1 和 reg2 是一样的，但是如果是第二种写法由于字符串的转义问题，`\` 要用 `\\` 表示。

再来看如何判断正则表达式是否匹配：

```js
const reg = /^\d{3}\-\d{5}$/;
reg.test("123-12345"); // true
reg.test("a123-12345"); // false
reg.test("123 12345"); //false
reg.test("123-1234a"); // false
```

RegExp 对象的 `test()` 方法用于测试给定的字符串是否符合条件。

## 切分字符串

用正则表达式切分字符串比用固定的字符串更灵活，请看正常的切分代码：

```js
"a b   c".split(" "); // ["a", "b", "“, "", "c"];
```

当我们想通过空格切割字符串时，我们没办法分割连续空格的情况。那么当我们使用正则表达式时：

```js
"a b   c".split(/\s*/); // ["a", "b", "c"]
```

这样不管是否是连续空格都可以正确切割。加入 `,` 试试：

```js
"a,b,  c d".split(/[\s\,]+/); // ["a", "b", "c", "d"]
```

再加入 `;` 试试：

```js
"a,b;; c  d".split(/[\s\;\,]+/); // ["a", "b", "c", "d"]
```

可见正则表达式在切割字符串上还是很方面的。

## 分组

除了简单地判断是否匹配以外，正则表达式还有提取子串的强大功能。用 `()` 表示的就是要提取的分组（Group）。比如：

`^(\d{4})-(\d{3,8})$` 分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

```js
const reg = /^(\d{4})-(\d{3,8})$/;
reg.exec("0755-12345678"); // ["0755-12345678", "0755", "12345678"]
reg.exec("0755 12345678"); // null
```

如果正则表达式定义了组，就可使用 `RegExp` 的 `exec` 方法提取子串出来。

`exec()` 方法在匹配成功后，会返回一个 `Array`，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

`exec()` 方法在匹配失败后会返回 `null`。

提取子串非常有用，来看一个更凶残的栗子：

```js
const reg =
  /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;
reg.exce("18:29:59"); // ["18:29:59", "18", "29", "59"]
```

这个正则表达式可以匹配合法的时间。但是有些时候，用正则表达式也无法做到完全认证，比如识别日期：

```js
const reg = /^(0[1-9]|1[0-2]|[0-9])\-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/;
```

对于 `2-30`、`4-31`这样的非法日期，用正则还是识别不了，或者说写出来非常困难。

## 贪婪匹配

需要注意的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的 `0`：

```js
const reg = /^(\d+)(0+)$/;
reg.exec("1023000"); // ["1023000", "102300", "0"]
```

由于 `\d+` 采用贪婪匹配，导致 `0+` 只匹配了一个 0.

必须让 `\d+` 采用非贪婪匹配（尽可能少地匹配），才能把后面的 0 都匹配到，加个 `?` 就可以让 `\d+` 采取非贪婪匹配：

```js
const reg = /^(\d+?)(0+)$/;
reg.exec("1023000"); // ["1023000", "1023", "000"];
```

这样就符合我们的预期了。

## 全局搜索

JavaScript 的正则表达式还有几个特殊的标志，最常用的是 `g`，表示全局匹配：

```js
const r1 = /test/g;
// 等价于
const r2 = new RegExp("test", "g");
```

全局匹配可以多次执行 `exec()` 方法来搜索一个匹配的字符串。当我们指定 `g` 标志后，每次运行 `exec()`，正则表达式本身会更新 `lastIndex` 属性，表示上次匹配到的最后索引：

```js
const str = "JavaScript, VbScript, JScript and ECMASciprt";
const reg = /[a-zA-Z]+Script/g;

// 使用全局匹配：
reg.exec(str); // ["JavaScript"]
reg.lastIndex; // 10

reg.exec(str); // VbScript
reg.lastIndex; // 20

reg.exec(str); // JScript
reg.lastIndex; // 29

reg.exec(str); // ECMAScript
reg.lastIndex; // 44

re.exec(str); // null，直到结果没有匹配到

// 如果再调用 exec() 则从头开始
```

全局匹配类似搜索，因此不能使用 `/^...$/`，那样最多匹配一次。

正则表达式还可以指定 `i` 标志，表示忽略大小写，`m` 标志表示执行多行匹配。

## 如何表达各类字符

| 字符 | 意义                                                                    |
| ---- | ----------------------------------------------------------------------- |
| `.`  | 匹配除终止符之外的任何单个字符：\n、\r、\u2028 或者 \u2029              |
| `\d` | 匹配任何数字（阿拉伯数字）。相当于 `[0-9]`                              |
| `\D` | 匹配任何非数字（阿拉伯数字）的字符。相当于 `[^0-9]`                     |
| `\w` | 匹配基本拉丁字母中的任何字母数字字符，包括下划线。相当于 `[a-zA-Z0-9_]` |
| `\W` | 匹配任何不适来自基本拉丁字符的单词字符。相当于 `[^a-zA-Z0-9_]`          |
| `\s` | 匹配空白字符，包括空格、tab、换页符、换行符和其他 unicode 空格          |
| `\S` | 匹配除了空白字符之外的字符                                              |

用的比较多的就是上面几种
